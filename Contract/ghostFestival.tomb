struct box_rom
{
//    created:timestamp;
    royalties:number;
}

struct box_ram
{
	name:string;
    description: string;
    imageURL:string;
    infoURL:string;
}

struct hammer_rom
{
//    created:timestamp;
    royalties:number;
}

struct hammer_ram
{
	name:string;
    description: string;
	imageURL:string;
    infoURL:string;
    rarity: string;
    model:string;
	hammerType:string;
	level:number;
	power:number;
    infusedType1:string;
    infusedType2:string;
}

struct ghost_rom
{
//    created:timestamp;
    royalties:number;
}

struct ghost_ram
{
	name:string;
    description:string;
	imageURL:string;
    infoURL:string;
    rarity: string;
    model:string;
	ghostType:string;
    level:number;
    health:number;
    infusedType1:string;
    infusedType2:string;
    unboxed:bool;
}

struct badge_rom
{
//    created:timestamp;
    royalties:number;
}

struct badge_ram
{
	name:string;
    description: string;
    imageURL:string;
    infoURL:string;
    rarity: string;
}

// hamma token contract
token GFEST{

	global _addressOwner: address;
    global _contractName: string;

    // boxPrice for common, rare, epic
    global _boxPrice: array<number>;
    // hammer total supply
    global _hammerSupply: array<number>;
    // ghost total supply
    global _ghostSupply: array<number>;

    // royalty for hammer and ghost
    global _royalty: number;

    // individual supplies
    global _raritySupplies: storage_list<number>;

    // hammer ending indices
    global _hammerEnding: storage_map<number, number>;

    // ghost ending indices
    global _ghostEnding: storage_map<number, number>;

    global _hammerStrStorageMap: storage_map<number, string>;
    global _hammerCurSupplyStorageMap: storage_map<number, number>;
    global _hammerMaxSupplyStorageMap: storage_map<number, number>;
    global _hammerStrPropertyCount: number;

    global _ghostStrStorageMap: storage_map<number, string>;
    global _ghostCurSupplyStorageMap: storage_map<number, number>;
    global _ghostMaxSupplyStorageMap: storage_map<number, number>;
    global _ghostStrPropertyCount: number;

    global _badgeStrStorageMap: storage_map<number, string>;
    global _badgeCurSupplyStorageMap: storage_map<number, number>;
    global _badgeMaxSupplyStorageMap: storage_map<number, number>;
    global _badgeStrPropertyCount: number;

    global _hammerSeriesShift: number;
    global _ghostSeriesShift: number;
    global _badgeSeriesShift: number;

    // token name
    property name: string = "Ghost Festival";
    // token version
    property version:string = "1.0";
    // token is transferable
    property isTransferable: bool = true;
    // token is not fungible
    property isFungible: bool = false;
    // token is burnable
    property isBurnable: bool = true;
    property isFinite: bool = false;
    // token owner address
    property owner: address = _addressOwner;
    // mandatory symbol
    property symbol: string = $THIS_SYMBOL;

    nft boxNft<box_rom, box_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}
    }

	nft hammerNft<hammer_rom, hammer_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}

        property model: string {
			return _RAM.model;
		}

		property hammerType: string {
			return _RAM.hammerType;
		}

		property level: number {
			return _RAM.level;
		}

	   property power: number {
			return _RAM.power;
	   }

       property infusedType1: string {
			return _RAM.infusedType1;
	   }

       property infusedType2: string {
			return _RAM.infusedType2;
	   }
	 }

    nft ghostNft<ghost_rom, ghost_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}

        property model: string {
			return _RAM.model;
		}

		property ghostType: string {
			return _RAM.ghostType;
		}

        property level: number {
			return _RAM.level;
		}

	   property health: number {
			return _RAM.health;
	   }

       property infusedType1: string {
			return _RAM.infusedType1;
	   }

       property infusedType2: string {
			return _RAM.infusedType2;
	   }

       property unboxed: bool {
			return _RAM.unboxed;
	   }
	}

    nft badgeNft<badge_rom, badge_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}
    }

    // librairies import
    import Runtime;
    import Token;
	import NFT;
    import Time;
    import Random;
    import Array;
    import Map;
    import List;

    // constructor with owner and all global var
    constructor(owner:address)
    {
        _addressOwner:= owner;
        _contractName:= "GFEST NFT";

        _royalty := 3;

        _boxPrice[1] := 1500000000;
        _boxPrice[2] := 4500000000;
        _boxPrice[3] := 25000000000;

        _hammerSupply[0] := 9000;
        _hammerSupply[1] := 3000;
        _hammerSupply[2] := 500;

        _ghostSupply[0] := 9000;
        _ghostSupply[1] := 3000;
        _ghostSupply[2] := 500;

        _raritySupplies.add(7200);
        _raritySupplies.add(1575);
        _raritySupplies.add(225);
        _raritySupplies.add(7200);
        _raritySupplies.add(1575);
        _raritySupplies.add(225);
        _raritySupplies.add(525);
        _raritySupplies.add(2325);
        _raritySupplies.add(150);
        _raritySupplies.add(525);
        _raritySupplies.add(2325);
        _raritySupplies.add(150);
        _raritySupplies.add(10);
        _raritySupplies.add(25);
        _raritySupplies.add(465);
        _raritySupplies.add(10);
        _raritySupplies.add(25);
        _raritySupplies.add(465);
/*
        _hammerSupply[0] := 6;
        _hammerSupply[1] := 6;
        _hammerSupply[2] := 3;

        _ghostSupply[0] := 6;
        _ghostSupply[1] := 6;
        _ghostSupply[2] := 3;

        _raritySupplies.add(3);
        _raritySupplies.add(2);
        _raritySupplies.add(1);
        _raritySupplies.add(3);
        _raritySupplies.add(2);
        _raritySupplies.add(1);
        _raritySupplies.add(2);
        _raritySupplies.add(3);
        _raritySupplies.add(1);
        _raritySupplies.add(2);
        _raritySupplies.add(3);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
        _raritySupplies.add(1);
*/
        _hammerStrPropertyCount := 8;
        _ghostStrPropertyCount := 8;
        _badgeStrPropertyCount := 4;

        _hammerSeriesShift := 100;
        _ghostSeriesShift := 200;
        _badgeSeriesShift := 4;
    }

    /// @dev Update the current token contract owner address to another address.
    /// @param newOwner - Address of the new owner - address
    public updateOwner(newOwner:address)
    {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new owner
        _addressOwner := newOwner;
    }

    public setHammerEndings(index: number, hammerEnding: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        _hammerEnding.set(index, hammerEnding);
    }

    public setGhostEndings(index: number, ghostEnding: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        _ghostEnding.set(index, ghostEnding);
    }

    public setHammerSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, model: string, hammerType: string, infusedType1: string, infusedType2: string, currentSupply: number, maxSupply: number) {
        if (editionId == 1) {
            _hammerStrStorageMap.set(1, imageURL);
            _hammerStrStorageMap.set(2, infoURL);
            _hammerStrStorageMap.set(3, name);
            _hammerStrStorageMap.set(4, rarity);
            _hammerStrStorageMap.set(5, model);
            _hammerStrStorageMap.set(6, hammerType);
            _hammerStrStorageMap.set(7, infusedType1);
            _hammerStrStorageMap.set(8, infusedType2);
        } else {
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 1, imageURL);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 2, infoURL);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 3, name);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 4, rarity);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 5, model);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 6, hammerType);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 7, infusedType1);
            _hammerStrStorageMap.set((editionId-1)*_hammerStrPropertyCount + 8, infusedType2);
        }

        _hammerCurSupplyStorageMap.set(editionId, currentSupply);
        _hammerMaxSupplyStorageMap.set(editionId, maxSupply);
    }

    public setGhostSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, model: string, ghostType: string, infusedType1: string, infusedType2: string, currentSupply: number, maxSupply: number) {
        if (editionId == 1) {
            _ghostStrStorageMap.set(1, imageURL);
            _ghostStrStorageMap.set(2, infoURL);
            _ghostStrStorageMap.set(3, name);
            _ghostStrStorageMap.set(4, rarity);
            _ghostStrStorageMap.set(5, model);
            _ghostStrStorageMap.set(6, ghostType);
            _ghostStrStorageMap.set(7, infusedType1);
            _ghostStrStorageMap.set(8, infusedType2);
        } else {
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 1, imageURL);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 2, infoURL);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 3, name);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 4, rarity);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 5, model);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 6, ghostType);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 7, infusedType1);
            _ghostStrStorageMap.set((editionId-1)*_ghostStrPropertyCount + 8, infusedType2);
        }
        
        _ghostCurSupplyStorageMap.set(editionId, currentSupply);
        _ghostMaxSupplyStorageMap.set(editionId, maxSupply);
    }

    public setBadgeSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, currentSupply: number, maxSupply: number) {
        if (editionId == 1) {
            _badgeStrStorageMap.set(1, imageURL);
            _badgeStrStorageMap.set(2, infoURL);
            _badgeStrStorageMap.set(3, name);
            _badgeStrStorageMap.set(4, rarity);
        } else {
            _badgeStrStorageMap.set((editionId-1)*_badgeStrPropertyCount + 1, imageURL);
            _badgeStrStorageMap.set((editionId-1)*_badgeStrPropertyCount + 2, infoURL);
            _badgeStrStorageMap.set((editionId-1)*_badgeStrPropertyCount + 3, name);
            _badgeStrStorageMap.set((editionId-1)*_badgeStrPropertyCount + 4, rarity);
        }

        _badgeCurSupplyStorageMap.set(editionId, currentSupply);
        _badgeMaxSupplyStorageMap.set(editionId, maxSupply);
    }

    public createBoxSeries() {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for box
        local index: number := 1;
        while (index <= 3) {
            NFT.createSeries(_addressOwner, $THIS_SYMBOL, index, 50000, TokenSeries.Duplicated, boxNft);
            index := index + 1;
        }
    }

    public createHammerSeries() {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for hammer
        local index: number := 1;
        while (index <= _hammerEnding.get(3)) {
            NFT.createSeries(_addressOwner, $THIS_SYMBOL, index + _hammerSeriesShift, _hammerMaxSupplyStorageMap.get(index), TokenSeries.Duplicated, hammerNft);
            index := index + 1;
        }
    }

    public createGhostSeries() {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for ghost
        local index: number := 1;
        while (index <= _ghostEnding.get(3)) {
            NFT.createSeries(_addressOwner, $THIS_SYMBOL, index + _ghostSeriesShift, _ghostMaxSupplyStorageMap.get(index), TokenSeries.Duplicated, ghostNft);
            index := index + 1;
        }
    }

    public createBadgeSeries() {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for badge
        local index: number := 1;
        while (index <= 3) {
            NFT.createSeries(_addressOwner, $THIS_SYMBOL, index + _badgeSeriesShift, _badgeMaxSupplyStorageMap.get(index), TokenSeries.Duplicated, badgeNft);
            index := index + 1;
        }
    }

    public withdraw(price: number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        local thisAddr: address := $THIS_ADDRESS;
        Token.transfer(thisAddr, _addressOwner, "SOUL", price);
    }

    private chooseRarityType(commonSupply: number, rareSupply: number, epicSupply: number): number {

        local rarityType: number := 0;
        local totalSupply: number := commonSupply + rareSupply + epicSupply;
        local rarityTypeValue :number := Random.generate() % totalSupply; // decides whether to choose common, rare or epic
        local subTotal: number := commonSupply + rareSupply;
        if (rarityTypeValue >= subTotal) {
            rarityType := 2;
        }
        else {
            if (rarityTypeValue >= commonSupply) {
                rarityType := 1;
            }
        }
        return rarityType;

    }

    private chooseNftIndex(nftType: number, rarityType: number): number {
        local startIndex: number;
        local subTotal: number := 0;

        local randomNFT: number;
        if (nftType == 1) {
            randomNFT := Random.generate() % _hammerSupply[rarityType];
        } else {
            randomNFT := Random.generate() % _ghostSupply[rarityType];
        }
        randomNFT := randomNFT + 1;

        if (rarityType == 0) {
            startIndex := 1;
        } else {
            if (nftType == 1) {
                startIndex := _hammerEnding.get(rarityType) + 1;
            } else {
                startIndex := _ghostEnding.get(rarityType) + 1;
            }
        }

        local endIndex: number;
        if (nftType == 1) {
            endIndex := _hammerEnding.get(rarityType + 1);
        } else {
            endIndex := _ghostEnding.get(rarityType + 1);
        }
        // calculate hammer, ghost index value that fits
        while(true) {
            if (startIndex > endIndex) {
                break;
            }
            local currentSupply: number;
            if (nftType == 1) {
                currentSupply := _hammerCurSupplyStorageMap.get(startIndex);
            } else {
                currentSupply := _ghostCurSupplyStorageMap.get(startIndex);
            }
            
            subTotal := subTotal + currentSupply;
            if (subTotal >= randomNFT) {
                break; // hammerIndex at this moment would be fine
            }
            startIndex := startIndex + 1;
        }

        return startIndex;
    }

    private decreaseSupplyAtIndex(nftType: number, index: number) {
        if (nftType == 1) {
            local curSupplyHammer: number := _hammerCurSupplyStorageMap.get(index);
            curSupplyHammer := curSupplyHammer - 1;
            _hammerCurSupplyStorageMap.set(index, curSupplyHammer);
        } else {
            local curSupplyGhost: number := _ghostCurSupplyStorageMap.get(index);
            curSupplyGhost := curSupplyGhost - 1;
            _ghostCurSupplyStorageMap.set(index, curSupplyGhost);
        }
    }

    private mintAndInfuse(owner:address, typeOfBox:number, hammerIndex:number, ghostIndex:number) {
        // mint box
        local rom1:box_rom := Struct.box_rom(_royalty);
        local ram1:box_ram := Struct.box_ram("GFEST Box", "GFEST Box", "", "");
        local boxTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom1, ram1, typeOfBox);

        // mint hammer
        local rom2:hammer_rom := Struct.hammer_rom(_royalty);
        local ram2:hammer_ram;        
        if (hammerIndex == 1) {
            ram2 := Struct.hammer_ram(_hammerStrStorageMap.get(3), _hammerStrStorageMap.get(3), _hammerStrStorageMap.get(1), _hammerStrStorageMap.get(2), _hammerStrStorageMap.get(4), _hammerStrStorageMap.get(5), _hammerStrStorageMap.get(6), 0, 0, _hammerStrStorageMap.get(7), _hammerStrStorageMap.get(8));
        } else {
            ram2 := Struct.hammer_ram(_hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 3), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 3), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 1), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 2), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 4), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 5), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 6), 0, 0, _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 7), _hammerStrStorageMap.get((hammerIndex - 1) * _hammerStrPropertyCount + 8));
        }
        local hammerTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom2, ram2, hammerIndex + _hammerSeriesShift);

        // mint ghost
        local rom3: ghost_rom := Struct.ghost_rom(_royalty);
        local ram3: ghost_ram;
        if (ghostIndex == 1) {
            ram3 := Struct.ghost_ram(_ghostStrStorageMap.get(3), _ghostStrStorageMap.get(3), _ghostStrStorageMap.get(1), _ghostStrStorageMap.get(2), _ghostStrStorageMap.get(4), _ghostStrStorageMap.get(5), _ghostStrStorageMap.get(6), 0, 0, _ghostStrStorageMap.get(7), _ghostStrStorageMap.get(8), false);
        } else {
            ram3 := Struct.ghost_ram(_ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 3), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 3), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 1), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 2), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 4), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 5), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 6), 0, 0, _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 7), _ghostStrStorageMap.get((ghostIndex - 1) * _ghostStrPropertyCount + 8), false);
        }
        local ghostTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom3, ram3, ghostIndex + _ghostSeriesShift);

        // mint badge
        local rom4: badge_rom := Struct.badge_rom(_royalty);
        local ram4: badge_ram;

        if (typeOfBox == 1) {
            ram4 := Struct.badge_ram(_badgeStrStorageMap.get(3), _badgeStrStorageMap.get(3), _badgeStrStorageMap.get(1), _badgeStrStorageMap.get(2), _badgeStrStorageMap.get(4));
        } else {
            ram4 := Struct.badge_ram(_badgeStrStorageMap.get((typeOfBox - 1) * _badgeStrPropertyCount + 3), _badgeStrStorageMap.get((typeOfBox - 1) * _badgeStrPropertyCount + 3), _ghostStrStorageMap.get((typeOfBox - 1) * _badgeStrPropertyCount + 1), _badgeStrStorageMap.get((typeOfBox - 1) * _badgeStrPropertyCount + 2), _badgeStrStorageMap.get((typeOfBox - 1) * _badgeStrPropertyCount + 4));
        }

        local badgeSeriesID: number := typeOfBox + _badgeSeriesShift;
        local badgeTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom4, ram4, badgeSeriesID);

        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, hammerTokenID);
        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, ghostTokenID);
        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, badgeTokenID);
    }

    public mint(owner:address, typeOfBox:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(owner), "invalid witness");

        local hammerCurrentSupply :number := 0;
        local ghostCurrentSupply :number := 0;
        local hammerType: number := 0; // 0: common, 1: rare, 2: epic
        local ghostType: number := 0; // 0: common, 1: rare, 2: epic

        if (typeOfBox == 1) { // common box
            hammerCurrentSupply := _raritySupplies.get(0) + _raritySupplies.get(6) + _raritySupplies.get(12);
            ghostCurrentSupply := _raritySupplies.get(3) + _raritySupplies.get(9) + _raritySupplies.get(15);

            // check the current type of box is all sold out
            Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
            Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

            hammerType := this.chooseRarityType(_raritySupplies.get(0), _raritySupplies.get(6), _raritySupplies.get(12));
            ghostType := this.chooseRarityType(_raritySupplies.get(3), _raritySupplies.get(9), _raritySupplies.get(15));

        }
        else {
            if (typeOfBox == 2) { // rare box
                hammerCurrentSupply := _raritySupplies.get(1) + _raritySupplies.get(7) + _raritySupplies.get(13);
                ghostCurrentSupply := _raritySupplies.get(4) + _raritySupplies.get(10) + _raritySupplies.get(16);

                // check the current type of box is all sold out
                Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
                Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

                hammerType := this.chooseRarityType(_raritySupplies.get(1), _raritySupplies.get(7), _raritySupplies.get(13));
                ghostType := this.chooseRarityType(_raritySupplies.get(4), _raritySupplies.get(10), _raritySupplies.get(16));

            } else {
                hammerCurrentSupply := _raritySupplies.get(2) + _raritySupplies.get(8) + _raritySupplies.get(14);
                ghostCurrentSupply := _raritySupplies.get(5) + _raritySupplies.get(11) + _raritySupplies.get(17);

                // check the current type of box is all sold out
                Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
                Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

                hammerType := this.chooseRarityType(_raritySupplies.get(2), _raritySupplies.get(8), _raritySupplies.get(14));
                ghostType := this.chooseRarityType(_raritySupplies.get(5), _raritySupplies.get(11), _raritySupplies.get(17));
            }
        }
        local hammerIndex: number;
        local ghostIndex: number;

        hammerIndex := this.chooseNftIndex(1, hammerType); // 1 means hammer
        ghostIndex := this.chooseNftIndex(2, ghostType); // 2 means ghost

        // Process the payment from the user in SOUL
        local thisAddr:address := $THIS_ADDRESS;
		Token.transfer(owner, thisAddr, "SOUL", _boxPrice[typeOfBox]);

        // mint Box, hammer and ghost, then infuse hammer and ghost into a box
        this.mintAndInfuse(owner, typeOfBox, hammerIndex, ghostIndex);

        // currentSupply of _hammerStorageMap and _ghostStorageMap at hammerIndex and ghostIndex should be decreased
        this.decreaseSupplyAtIndex(1, hammerIndex);
        this.decreaseSupplyAtIndex(2, ghostIndex);

        // decrease current supply for ghost and hammer for the selected type
        typeOfBox := typeOfBox - 1;
        local myTypeOfBox: number := typeOfBox;
        local newSupply: number := 0;

        if (hammerType == 0) {
            myTypeOfBox := typeOfBox;
            if (myTypeOfBox == 0) {
                newSupply := _raritySupplies.get(0) - 1;
                _raritySupplies.replace(0, newSupply);
            }
            if (myTypeOfBox == 1) {
                newSupply := _raritySupplies.get(1) - 1;
                _raritySupplies.replace(1, newSupply);
            }
            if (myTypeOfBox == 2) {
                newSupply := _raritySupplies.get(2) - 1;
                _raritySupplies.replace(2, newSupply);
            }
        } else {
            if (hammerType == 1) {
                myTypeOfBox := typeOfBox + 6;
                if (myTypeOfBox == 6) {
                    newSupply := _raritySupplies.get(6) - 1;
                    _raritySupplies.replace(6, newSupply);
                }
                if (myTypeOfBox == 7) {
                    newSupply := _raritySupplies.get(7) - 1;
                    _raritySupplies.replace(7, newSupply);
                }
                if (myTypeOfBox == 8) {
                    newSupply := _raritySupplies.get(8) - 1;
                    _raritySupplies.replace(8, newSupply);
                }
            }
            if (hammerType == 2) {
                myTypeOfBox := typeOfBox + 12;
                if (myTypeOfBox == 12) {
                    newSupply := _raritySupplies.get(12) - 1;
                    _raritySupplies.replace(12, newSupply);
                }
                if (myTypeOfBox == 13) {
                    newSupply := _raritySupplies.get(13) - 1;
                    _raritySupplies.replace(13, newSupply);
                }
                if (myTypeOfBox == 14) {
                    newSupply := _raritySupplies.get(14) - 1;
                    _raritySupplies.replace(14, newSupply);
                }
            }
        }    
        if (ghostType == 0) {
            myTypeOfBox := typeOfBox + 3;
            if (myTypeOfBox == 3) {
                newSupply := _raritySupplies.get(3) - 1;
                _raritySupplies.replace(3, newSupply);
            }
            if (myTypeOfBox == 4) {
                newSupply := _raritySupplies.get(4) - 1;
                _raritySupplies.replace(4, newSupply);
            }
            if (myTypeOfBox == 5) {
                newSupply := _raritySupplies.get(5) - 1;
                _raritySupplies.replace(5, newSupply);
            }
        } else {
            if (ghostType == 1) {
                myTypeOfBox := typeOfBox + 9;
                if (myTypeOfBox == 9) {
                    newSupply := _raritySupplies.get(9) - 1;
                    _raritySupplies.replace(9, newSupply);
                }
                if (myTypeOfBox == 10) {
                    newSupply := _raritySupplies.get(10) - 1;
                    _raritySupplies.replace(10, newSupply);
                }
                if (myTypeOfBox == 11) {
                    newSupply := _raritySupplies.get(11) - 1;
                    _raritySupplies.replace(11, newSupply);
                }
            }
            if (ghostType == 2) {
                myTypeOfBox := typeOfBox + 15;
                if (myTypeOfBox == 15) {
                    newSupply := _raritySupplies.get(15) - 1;
                    _raritySupplies.replace(15, newSupply);
                }
                if (myTypeOfBox == 16) {
                    newSupply := _raritySupplies.get(16) - 1;
                    _raritySupplies.replace(16, newSupply);
                }
                if (myTypeOfBox == 17) {
                    newSupply := _raritySupplies.get(17) - 1;
                    _raritySupplies.replace(17, newSupply);
                }
            }
        }

        _hammerSupply[hammerType] := _hammerSupply[hammerType] - 1;
        _ghostSupply[ghostType] := _ghostSupply[ghostType] - 1;
    }

    public burn(from:address, symbol:string, id:number) {
        NFT.burn(from, symbol, id);
    }

    public getTempBadgeString(index: number): string {
        return _badgeStrStorageMap.get(index);
    }

	/// @dev onUpgrade trigger.
    /// @param from - Address from - address
	trigger onUpgrade(from:address)
    {
        // check is witness and is current owner
		Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");
    }
}