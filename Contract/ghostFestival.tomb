struct box_rom
{
//    created:timestamp;
    royalties:number;
}

struct box_ram
{
	name:string;
    description: string;
    imageURL:string;
    infoURL:string;
}

struct hammer_rom
{
//    created:timestamp;
    royalties:number;
}

struct hammer_ram
{
	name:string;
    description: string;
	imageURL:string;
    infoURL:string;
    rarity: string;
    model:string;
	hammerType:string;
	level:number;
	power:number;
    infusedType1:string;
    infusedType2:string;
}

struct ghost_rom
{
//    created:timestamp;
    royalties:number;
}

struct ghost_ram
{
	name:string;
    description:string;
	imageURL:string;
    infoURL:string;
    rarity: string;
    model:string;
	ghostType:string;
    level:number;
    health:number;
    infusedType1:string;
    infusedType2:string;
    unboxed:bool;
}

struct badge_rom
{
//    created:timestamp;
    royalties:number;
}

struct badge_ram
{
	name:string;
    description: string;
    imageURL:string;
    infoURL:string;
    rarity: string;
}

// hamma token contract
token GFNFT{

	global _addressOwner: address;
    global _contractName: string;

    // boxPrice for common, rare, epic
    global _boxPrice: array<number>;
    // hammer total supply
    global _hammerSupply: array<number>;
    // ghost total supply
    global _ghostSupply: array<number>;

    // royalty for hammer and ghost
    global _royalty: number;

    // individual supplies
    global _raritySupplies: storage_list<number>;

    // hammer ending indices
    global _hammerEnding: storage_map<number, number>;

    // ghost ending indices
    global _ghostEnding: storage_map<number, number>;

    global _hammerStrStorageMap: storage_map<number, string>;
    global _hammerCurSupplyStorageMap: storage_map<number, number>;
    global _hammerMaxSupplyStorageMap: storage_map<number, number>;
    global _hammerStrPropertyCount: number;

    global _ghostStrStorageMap: storage_map<number, string>;
    global _ghostCurSupplyStorageMap: storage_map<number, number>;
    global _ghostMaxSupplyStorageMap: storage_map<number, number>;
    global _ghostStrPropertyCount: number;

    global _badgeStrStorageMap: storage_map<number, string>;
    global _badgeCurSupplyStorageMap: storage_map<number, number>;
    global _badgeMaxSupplyStorageMap: storage_map<number, number>;
    global _badgeStrPropertyCount: number;

    global _hammerSeriesShift: number;
    global _ghostSeriesShift: number;
    global _badgeSeriesShift: number;

    global _hammerTokenIDStorageMap: storage_map<number, number>;
    global _ghostTokenIDStorageMap: storage_map<number, number>;
    global _badgeTokenIDStorageMap: storage_map<number, number>;
    global _boxTokenIDStorageMap: storage_map<number, number>;

    global _boxIdToHammerIndex: storage_map<number, number>;
    global _boxIdToGhostIndex: storage_map<number, number>;
    global _boxIdToBadgeIndex: storage_map<number, number>;

    global _burnMap: storage_map<number, bool>;

    // bloot crates
    global _blootBoxMaxSupply: number;
    global _blootBoxCurrentID: number;
    global _blootBoxIdToTokenID: storage_map<number, number>;
    global _blootWhitelist: storage_map<string, number>;

    // specky hammer and ghost
    global _speckyCommonMaxSupply: number;
    global _speckyRareMaxSupply: number;
    global _speckyEpicMaxSupply: number;

    global _speckyCommonCurrentSupply: number;
    global _speckyRareCurrentSupply: number;
    global _speckyEpicCurrentSupply: number;

    global _speckyBoxId: number;
    global _speckyHammerId: number;
    global _speckyGhostId: number;
    global _boxIdToSpeckyHammerNum: storage_map<number, number>;
    global _boxIdToSpeckyGhostNum: storage_map<number, number>;

    global _tcktSymbol: string;

    // token name
    property name: string = "Ghost Festival";
    // token version
    property version:string = "1.0";
    // token is transferable
    property isTransferable: bool = true;
    // token is not fungible
    property isFungible: bool = false;
    // token is burnable
    property isBurnable: bool = true;
    property isFinite: bool = false;
    // token owner address
    property owner: address = _addressOwner;
    // mandatory symbol
    property symbol: string = $THIS_SYMBOL;

    nft boxNft<box_rom, box_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}
    }

	nft hammerNft<hammer_rom, hammer_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}

        property model: string {
			return _RAM.model;
		}

		property hammerType: string {
			return _RAM.hammerType;
		}

		property level: number {
			return _RAM.level;
		}

	   property power: number {
			return _RAM.power;
	   }

       property infusedType1: string {
			return _RAM.infusedType1;
	   }

       property infusedType2: string {
			return _RAM.infusedType2;
	   }
	 }

    nft ghostNft<ghost_rom, ghost_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}

        property model: string {
			return _RAM.model;
		}

		property ghostType: string {
			return _RAM.ghostType;
		}

        property level: number {
			return _RAM.level;
		}

	   property health: number {
			return _RAM.health;
	   }

       property infusedType1: string {
			return _RAM.infusedType1;
	   }

       property infusedType2: string {
			return _RAM.infusedType2;
	   }

       property unboxed: bool {
			return _RAM.unboxed;
	   }
	}

    nft badgeNft<badge_rom, badge_ram> {
/*
        property created:timestamp {
             return _ROM.created;
        }
*/
        property royalties:number {
             return _ROM.royalties;
        }

		property name: string {
			return _RAM.name;
		}

	    property description:string {
            return _RAM.description;
        }

		property imageURL: string {
			return _RAM.imageURL;
		}

        property infoURL: string {
			return _RAM.infoURL;
		}

        property rarity: string {
			return _RAM.rarity;
		}
    }

    // librairies import
    import Runtime;
    import Token;
	import NFT;
    import Time;
    import Random;
    import Array;
    import Map;
    import List;

    // constructor with owner and all global var
    constructor(owner:address)
    {
        _addressOwner:= owner;
        _contractName:= "GFNFT";

        _royalty := 3;

        _boxPrice[1] := 1500000000;
        _boxPrice[2] := 4500000000;
        _boxPrice[3] := 25000000000;

        _hammerSupply[0] := 9000;
        _hammerSupply[1] := 3000;
        _hammerSupply[2] := 500;

        _ghostSupply[0] := 9000;
        _ghostSupply[1] := 3000;
        _ghostSupply[2] := 500;

        _hammerStrPropertyCount := 8;
        _ghostStrPropertyCount := 8;
        _badgeStrPropertyCount := 4;

        _hammerSeriesShift := 10;
        _ghostSeriesShift := 50;
        _badgeSeriesShift := 4;

        _blootBoxMaxSupply := 2268;
        _blootBoxCurrentID := 1;

        _speckyCommonMaxSupply := 1000;
        _speckyRareMaxSupply := 522;
        _speckyEpicMaxSupply := 500;

        _speckyCommonCurrentSupply := 1;
        _speckyRareCurrentSupply := 1;
        _speckyEpicCurrentSupply := 1;

        _speckyBoxId := 1;
        _speckyHammerId := 1;
        _speckyGhostId := 1;

        _tcktSymbol := "TCKT";
    }

    /// @dev Update the current token contract owner address to another address.
    /// @param newOwner - Address of the new owner - address
    public updateOwner(newOwner:address)
    {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // set new owner
        _addressOwner := newOwner;
    }

    public setHammerEndings(index: number, hammerEnding: number) {

    }

    public setGhostEndings(index: number, ghostEnding: number) {

    }

    public setHammerTokenIDSource(editionId: number, tokenID: number) {

    }

    public setGhostTokenIDSource(editionId: number, tokenID: number) {

    }

    public setBadgeTokenIDSource(editionId: number, tokenID: number) {

    }

    public setBoxTokenIDSource(editionId: number, tokenID: number) {

    }

    public setHammerSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, model: string, hammerType: string, infusedType1: string, infusedType2: string, currentSupply: number, maxSupply: number) {
      
    }

    public setGhostSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, model: string, ghostType: string, infusedType1: string, infusedType2: string, currentSupply: number, maxSupply: number) {
        
    }

    public setBadgeSource(editionId: number, imageURL: string, infoURL: string, name: string, rarity: string, currentSupply: number, maxSupply: number) {
        
    }

    public createBoxSeries() {

    }

    public createHammerSeries() {

    }

    public createGhostSeries() {

    }

    public createBadgeSeries() {

    }

    public createGenericBoxSeries(editionId: number, maxSupply: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for box
        NFT.createSeries(_addressOwner, $THIS_SYMBOL, editionId, maxSupply, TokenSeries.Duplicated, boxNft);
    }

    public createGenericHammerSeries(editionId: number, maxSupply: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for box
        NFT.createSeries(_addressOwner, $THIS_SYMBOL, editionId, maxSupply, TokenSeries.Duplicated, hammerNft);
    }

    public createGenericGhostSeries(editionId: number, maxSupply: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for box
        NFT.createSeries(_addressOwner, $THIS_SYMBOL, editionId, maxSupply, TokenSeries.Duplicated, ghostNft);
    }

    public createGenericBadgeSeries(editionId: number, maxSupply: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        // create series for box
        NFT.createSeries(_addressOwner, $THIS_SYMBOL, editionId, maxSupply, TokenSeries.Duplicated, badgeNft);
    }

    public withdraw(price: number)
    {

    }

    private chooseRarityType(commonSupply: number, rareSupply: number, epicSupply: number): number {

        local rarityType: number := 0;
        local totalSupply: number := commonSupply + rareSupply + epicSupply;
        local rarityTypeValue :number := Random.generate() % totalSupply; // decides whether to choose common, rare or epic
        local subTotal: number := commonSupply + rareSupply;
        if (rarityTypeValue >= subTotal) {
            rarityType := 2;
        }
        else {
            if (rarityTypeValue >= commonSupply) {
                rarityType := 1;
            }
        }
        return rarityType;

    }

    private chooseNftIndex(nftType: number, rarityType: number): number {
        local startIndex: number;
        local subTotal: number := 0;

        local randomNFT: number;
        if (nftType == 1) {
            randomNFT := Random.generate() % _hammerSupply[rarityType];
        } else {
            randomNFT := Random.generate() % _ghostSupply[rarityType];
        }
        randomNFT := randomNFT + 1;

        if (rarityType == 0) {
            startIndex := 1;
        } else {
            if (nftType == 1) {
                startIndex := _hammerEnding.get(rarityType) + 1;
            } else {
                startIndex := _ghostEnding.get(rarityType) + 1;
            }
        }

        local endIndex: number;
        if (nftType == 1) {
            endIndex := _hammerEnding.get(rarityType + 1);
        } else {
            endIndex := _ghostEnding.get(rarityType + 1);
        }
        // calculate hammer, ghost index value that fits
        while(true) {
            if (startIndex > endIndex) {
                break;
            }
            local currentSupply: number;
            if (nftType == 1) {
                currentSupply := _hammerCurSupplyStorageMap.get(startIndex);
            } else {
                currentSupply := _ghostCurSupplyStorageMap.get(startIndex);
            }
            
            subTotal := subTotal + currentSupply;
            if (subTotal >= randomNFT) {
                break; // hammerIndex at this moment would be fine
            }
            startIndex := startIndex + 1;
        }

        return startIndex;
    }

    private decreaseSupplyAtIndex(nftType: number, index: number) {
        if (nftType == 1) {
            local curSupplyHammer: number := _hammerCurSupplyStorageMap.get(index);
            curSupplyHammer := curSupplyHammer - 1;
            _hammerCurSupplyStorageMap.set(index, curSupplyHammer);
        } else {
            local curSupplyGhost: number := _ghostCurSupplyStorageMap.get(index);
            curSupplyGhost := curSupplyGhost - 1;
            _ghostCurSupplyStorageMap.set(index, curSupplyGhost);
        }
    }

    private mintAndInfuse(owner:address, typeOfBox:number, hammerIndex:number, ghostIndex:number) {

        // mint box
        local rom1:box_rom := Struct.box_rom(_royalty);       
        local ram1:box_ram;
        if (typeOfBox == 1) {
            ram1 := Struct.box_ram("Common Crate", "Common Crate", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/Crate_1.mp4", "ipfs://QmcXCb913p3di5qj6sERNb69MJHHYmC614PZjg7ERSEq3c/" + _boxTokenIDStorageMap.get(typeOfBox));
        } else {
            if (typeOfBox == 2) {
                ram1 := Struct.box_ram("Rare Crate", "Rare Crate", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/Crate_2.mp4", "ipfs://QmcXCb913p3di5qj6sERNb69MJHHYmC614PZjg7ERSEq3c/" + _boxTokenIDStorageMap.get(typeOfBox));
            } else {
                ram1 := Struct.box_ram("Epic Crate", "Epic Crate", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/Crate_3.mp4", "ipfs://QmcXCb913p3di5qj6sERNb69MJHHYmC614PZjg7ERSEq3c/" + _boxTokenIDStorageMap.get(typeOfBox));
            }
        }

        local boxTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom1, ram1, typeOfBox);

        _boxIdToHammerIndex.set(boxTokenID, hammerIndex);
        _boxIdToGhostIndex.set(boxTokenID, ghostIndex);
        _boxIdToBadgeIndex.set(boxTokenID, typeOfBox);

        _boxIdToSpeckyHammerNum.set(boxTokenID, 0);
        _boxIdToSpeckyGhostNum.set(boxTokenID, 0);
      
        if (typeOfBox == 1) {
            local isSpeckyBoxEven: number := _speckyBoxId % 2;
            if (_speckyCommonCurrentSupply <= _speckyCommonMaxSupply) {
                if (isSpeckyBoxEven == 1) {
                    _boxIdToSpeckyHammerNum.set(boxTokenID, 1);
                } else {
                    _boxIdToSpeckyGhostNum.set(boxTokenID, 1);
                }
                _speckyBoxId := _speckyBoxId + 1;
                _speckyCommonCurrentSupply := _speckyCommonCurrentSupply + 1;
            }
        }  else {
            if (typeOfBox == 2) {
                if (_speckyRareCurrentSupply <= _speckyRareMaxSupply) {
                    _boxIdToSpeckyHammerNum.set(boxTokenID, 1);
                    _boxIdToSpeckyGhostNum.set(boxTokenID, 1);
                    _speckyRareCurrentSupply := _speckyRareCurrentSupply + 1;
                }
            } else {
                if (_speckyEpicCurrentSupply <= _speckyEpicMaxSupply) {
                    _boxIdToSpeckyHammerNum.set(boxTokenID, 5);
                    _boxIdToSpeckyGhostNum.set(boxTokenID, 5);
                    _speckyEpicCurrentSupply := _speckyEpicCurrentSupply + 1;
                }
            }
        }

/*
        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, hammerTokenID);
        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, ghostTokenID);
        NFT.infuse(owner, $THIS_SYMBOL, boxTokenID, $THIS_SYMBOL, badgeTokenID);
*/  
    }

    private increaseTokenID(typeOfBox: number, hammerIndex: number, ghostIndex: number) {
        local boxTokenID :number := _boxTokenIDStorageMap.get(typeOfBox);
        local hammerTokenID :number := _hammerTokenIDStorageMap.get(hammerIndex);
        local ghostTokenID :number := _ghostTokenIDStorageMap.get(ghostIndex);
        local badgeTokenID :number := _badgeTokenIDStorageMap.get(typeOfBox);
        
        boxTokenID := boxTokenID + 1;
        hammerTokenID := hammerTokenID + 1;
        ghostTokenID := ghostTokenID + 1;
        badgeTokenID := badgeTokenID + 1;

        _boxTokenIDStorageMap.set(typeOfBox, boxTokenID);
        _hammerTokenIDStorageMap.set(hammerIndex, hammerTokenID);
        _ghostTokenIDStorageMap.set(ghostIndex, ghostTokenID);
        _badgeTokenIDStorageMap.set(typeOfBox, badgeTokenID);
    }

    public mint(owner:address, typeOfBox:number)
    {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(owner), "invalid witness");

        local hammerCurrentSupply :number := 0;
        local ghostCurrentSupply :number := 0;
        local hammerType: number := 0; // 0: common, 1: rare, 2: epic
        local ghostType: number := 0; // 0: common, 1: rare, 2: epic

        if (typeOfBox == 1) { // common box
            hammerCurrentSupply := _raritySupplies.get(0) + _raritySupplies.get(6) + _raritySupplies.get(12);
            ghostCurrentSupply := _raritySupplies.get(3) + _raritySupplies.get(9) + _raritySupplies.get(15);

            // check the current type of box is all sold out
            Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
            Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

            hammerType := this.chooseRarityType(_raritySupplies.get(0), _raritySupplies.get(6), _raritySupplies.get(12));
            ghostType := this.chooseRarityType(_raritySupplies.get(3), _raritySupplies.get(9), _raritySupplies.get(15));

        }
        else {
            if (typeOfBox == 2) { // rare box
                hammerCurrentSupply := _raritySupplies.get(1) + _raritySupplies.get(7) + _raritySupplies.get(13);
                ghostCurrentSupply := _raritySupplies.get(4) + _raritySupplies.get(10) + _raritySupplies.get(16);

                // check the current type of box is all sold out
                Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
                Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

                hammerType := this.chooseRarityType(_raritySupplies.get(1), _raritySupplies.get(7), _raritySupplies.get(13));
                ghostType := this.chooseRarityType(_raritySupplies.get(4), _raritySupplies.get(10), _raritySupplies.get(16));

            } else {
                hammerCurrentSupply := _raritySupplies.get(2) + _raritySupplies.get(8) + _raritySupplies.get(14);
                ghostCurrentSupply := _raritySupplies.get(5) + _raritySupplies.get(11) + _raritySupplies.get(17);

                // check the current type of box is all sold out
                Runtime.expect(hammerCurrentSupply > 0, "The box type you required is sold out");
                Runtime.expect(ghostCurrentSupply > 0, "The box type you required is sold out");

                hammerType := this.chooseRarityType(_raritySupplies.get(2), _raritySupplies.get(8), _raritySupplies.get(14));
                ghostType := this.chooseRarityType(_raritySupplies.get(5), _raritySupplies.get(11), _raritySupplies.get(17));
            }
        }
        local hammerIndex: number;
        local ghostIndex: number;

        hammerIndex := this.chooseNftIndex(1, hammerType); // 1 means hammer
        ghostIndex := this.chooseNftIndex(2, ghostType); // 2 means ghost

        // Process the payment from the user in SOUL
		Token.transfer(owner, _addressOwner, "SOUL", _boxPrice[typeOfBox]);

        // mint Box, hammer and ghost, then infuse hammer and ghost into a box
        this.mintAndInfuse(owner, typeOfBox, hammerIndex, ghostIndex);

        this.increaseTokenID(typeOfBox, hammerIndex, ghostIndex);

        // currentSupply of _hammerStorageMap and _ghostStorageMap at hammerIndex and ghostIndex should be decreased
        this.decreaseSupplyAtIndex(1, hammerIndex);
        this.decreaseSupplyAtIndex(2, ghostIndex);

        // decrease current supply for ghost and hammer for the selected type
        typeOfBox := typeOfBox - 1;
        local myTypeOfBox: number := typeOfBox;
        local newSupply: number := 0;

        if (hammerType == 0) {
            myTypeOfBox := typeOfBox;
            if (myTypeOfBox == 0) {
                newSupply := _raritySupplies.get(0) - 1;
                _raritySupplies.replace(0, newSupply);
            }
            if (myTypeOfBox == 1) {
                newSupply := _raritySupplies.get(1) - 1;
                _raritySupplies.replace(1, newSupply);
            }
            if (myTypeOfBox == 2) {
                newSupply := _raritySupplies.get(2) - 1;
                _raritySupplies.replace(2, newSupply);
            }
        } else {
            if (hammerType == 1) {
                myTypeOfBox := typeOfBox + 6;
                if (myTypeOfBox == 6) {
                    newSupply := _raritySupplies.get(6) - 1;
                    _raritySupplies.replace(6, newSupply);
                }
                if (myTypeOfBox == 7) {
                    newSupply := _raritySupplies.get(7) - 1;
                    _raritySupplies.replace(7, newSupply);
                }
                if (myTypeOfBox == 8) {
                    newSupply := _raritySupplies.get(8) - 1;
                    _raritySupplies.replace(8, newSupply);
                }
            }
            if (hammerType == 2) {
                myTypeOfBox := typeOfBox + 12;
                if (myTypeOfBox == 12) {
                    newSupply := _raritySupplies.get(12) - 1;
                    _raritySupplies.replace(12, newSupply);
                }
                if (myTypeOfBox == 13) {
                    newSupply := _raritySupplies.get(13) - 1;
                    _raritySupplies.replace(13, newSupply);
                }
                if (myTypeOfBox == 14) {
                    newSupply := _raritySupplies.get(14) - 1;
                    _raritySupplies.replace(14, newSupply);
                }
            }
        }    
        if (ghostType == 0) {
            myTypeOfBox := typeOfBox + 3;
            if (myTypeOfBox == 3) {
                newSupply := _raritySupplies.get(3) - 1;
                _raritySupplies.replace(3, newSupply);
            }
            if (myTypeOfBox == 4) {
                newSupply := _raritySupplies.get(4) - 1;
                _raritySupplies.replace(4, newSupply);
            }
            if (myTypeOfBox == 5) {
                newSupply := _raritySupplies.get(5) - 1;
                _raritySupplies.replace(5, newSupply);
            }
        } else {
            if (ghostType == 1) {
                myTypeOfBox := typeOfBox + 9;
                if (myTypeOfBox == 9) {
                    newSupply := _raritySupplies.get(9) - 1;
                    _raritySupplies.replace(9, newSupply);
                }
                if (myTypeOfBox == 10) {
                    newSupply := _raritySupplies.get(10) - 1;
                    _raritySupplies.replace(10, newSupply);
                }
                if (myTypeOfBox == 11) {
                    newSupply := _raritySupplies.get(11) - 1;
                    _raritySupplies.replace(11, newSupply);
                }
            }
            if (ghostType == 2) {
                myTypeOfBox := typeOfBox + 15;
                if (myTypeOfBox == 15) {
                    newSupply := _raritySupplies.get(15) - 1;
                    _raritySupplies.replace(15, newSupply);
                }
                if (myTypeOfBox == 16) {
                    newSupply := _raritySupplies.get(16) - 1;
                    _raritySupplies.replace(16, newSupply);
                }
                if (myTypeOfBox == 17) {
                    newSupply := _raritySupplies.get(17) - 1;
                    _raritySupplies.replace(17, newSupply);
                }
            }
        }

        _hammerSupply[hammerType] := _hammerSupply[hammerType] - 1;
        _ghostSupply[ghostType] := _ghostSupply[ghostType] - 1;
    }
/*
    public burn(from:address, symbol:string, tokenID:number) {

    }
*/
    public burnOnWebsite(from:address, symbol:string, tokenID:number) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");
        
        _burnMap.set(tokenID, true);
        NFT.burn(from, symbol, tokenID);

        local hammerIndex: number := _boxIdToHammerIndex.get(tokenID);
        local ghostIndex: number := _boxIdToGhostIndex.get(tokenID);
        local badgeIndex: number := _boxIdToBadgeIndex.get(tokenID);

        _boxIdToHammerIndex.remove(hammerIndex);
        _boxIdToGhostIndex.remove(ghostIndex);
        _boxIdToBadgeIndex.remove(badgeIndex);

        if (hammerIndex <= 0) {
            return;
        }
        if (ghostIndex <= 0) {
            return;
        }
        if (badgeIndex <= 0) {
            return;
        }

        if (symbol != $THIS_SYMBOL) {
            return;
        }

        local temp: number := 0;

        // mint hammer
        local rom2:hammer_rom := Struct.hammer_rom(_royalty);
        local ram2:hammer_ram;        
        if (hammerIndex == 1) {
            ram2 := Struct.hammer_ram(_hammerStrStorageMap.get(3), _hammerStrStorageMap.get(3), _hammerStrStorageMap.get(1), "ipfs://QmXAEPp1NhgQh8hmXuRCALknjyrK4DosFaVHFe1izbjNhg/" + _hammerTokenIDStorageMap.get(hammerIndex), _hammerStrStorageMap.get(4), _hammerStrStorageMap.get(5), _hammerStrStorageMap.get(6), 0, 0, _hammerStrStorageMap.get(7), _hammerStrStorageMap.get(8));
        } else {
            temp := (hammerIndex - 1) * _hammerStrPropertyCount;
            ram2 := Struct.hammer_ram(_hammerStrStorageMap.get(temp+3), _hammerStrStorageMap.get(temp+3), _hammerStrStorageMap.get(temp + 1), "ipfs://QmXAEPp1NhgQh8hmXuRCALknjyrK4DosFaVHFe1izbjNhg/" + _hammerTokenIDStorageMap.get(hammerIndex), _hammerStrStorageMap.get(temp + 4), _hammerStrStorageMap.get(temp + 5), _hammerStrStorageMap.get(temp + 6), 0, 0, _hammerStrStorageMap.get(temp + 7), _hammerStrStorageMap.get(temp + 8));
        }
        NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom2, ram2, hammerIndex + _hammerSeriesShift);

        // mint ghost
        local rom3: ghost_rom := Struct.ghost_rom(_royalty);
        local ram3: ghost_ram;
        if (ghostIndex == 1) {
            ram3 := Struct.ghost_ram(_ghostStrStorageMap.get(3), _ghostStrStorageMap.get(3), _ghostStrStorageMap.get(1), "ipfs://QmcTMDAQaRugNhz5mS1Kc3tCN1zr3TUsctWByA9KCqsnGd/" + _ghostTokenIDStorageMap.get(ghostIndex), _ghostStrStorageMap.get(4), _ghostStrStorageMap.get(5), _ghostStrStorageMap.get(6), 0, 0, _ghostStrStorageMap.get(7), _ghostStrStorageMap.get(8), false);
        } else {
            temp := (ghostIndex - 1) * _ghostStrPropertyCount;
            ram3 := Struct.ghost_ram(_ghostStrStorageMap.get(temp+3), _ghostStrStorageMap.get(temp+3), _ghostStrStorageMap.get(temp + 1), "ipfs://QmcTMDAQaRugNhz5mS1Kc3tCN1zr3TUsctWByA9KCqsnGd/" + _ghostTokenIDStorageMap.get(ghostIndex), _ghostStrStorageMap.get(temp + 4), _ghostStrStorageMap.get(temp + 5), _ghostStrStorageMap.get(temp + 6), 0, 0, _ghostStrStorageMap.get(temp + 7), _ghostStrStorageMap.get(temp + 8), false);
        }
        NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom3, ram3, ghostIndex + _ghostSeriesShift);

        // mint badge
        local rom4: badge_rom := Struct.badge_rom(_royalty);
        local ram4: badge_ram;

        if (badgeIndex == 1) {
            ram4 := Struct.badge_ram("Normal Badge", "Normal Badge", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/badge_normal.mp4", "ipfs://Qmd5Pr3cqFkv6kf6TtzNwJKpoX2xMbpZGSxryGJ1UDnpnG/" + _badgeTokenIDStorageMap.get(badgeIndex), "Common");
        } else {
            if (badgeIndex == 2) {
                ram4 := Struct.badge_ram("Silver Badge", "Silver Badge", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/badge_silver.mp4", "ipfs://Qmd5Pr3cqFkv6kf6TtzNwJKpoX2xMbpZGSxryGJ1UDnpnG/" + _badgeTokenIDStorageMap.get(badgeIndex), "Rare");
            } else {
                ram4 := Struct.badge_ram("Golden Badge", "Golden Badge", "ipfs://QmaawWqovxBR66zTHLGgPvtxCNkD9H6fLmRP9EmoyrxoTb/badge_golden.mp4", "ipfs://Qmd5Pr3cqFkv6kf6TtzNwJKpoX2xMbpZGSxryGJ1UDnpnG/" + _badgeTokenIDStorageMap.get(badgeIndex), "Epic");
            }
        }

        local badgeSeriesID: number := badgeIndex + _badgeSeriesShift;
        NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom4, ram4, badgeSeriesID);

        local speckyHammerNum: number := _boxIdToSpeckyHammerNum.get(tokenID);
        local speckyGhostNum: number := _boxIdToSpeckyGhostNum.get(tokenID);
        local index: number := 1;

        if (speckyHammerNum > 0) {
            index := 1;
            while (index <= speckyHammerNum) {
                // mint specky hammer
                rom2 := Struct.hammer_rom(_royalty);
                ram2 := Struct.hammer_ram("Rare Specky Hammer", "Rare Specky Hammer", "ipfs://QmVdZxqZPJhyB6XRjCj2khDXJnkZuzcmjxJFdM3AdNUmt7/hammer_specky_1.mp4", "ipfs://QmcnYUBthC8bwf7666Ye3BfCXn84vprEKdRUCw5uD4jiFT/1", "Rare", "Rare", "OG", 0, 0, "None", "None");
                NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom2, ram2, 42);

                index := index + 1;
//                _speckyHammerId := _speckyHammerId + 1;
            }
        }

        if (speckyGhostNum > 0) {
            index := 1;
            while (index <= speckyGhostNum) {
                // mint specky ghost
                rom3 := Struct.ghost_rom(_royalty);
                ram3 := Struct.ghost_ram("Rare Translucent Ghost", "Rare Translucent Ghost", "ipfs://QmVdZxqZPJhyB6XRjCj2khDXJnkZuzcmjxJFdM3AdNUmt7/ghost_translucent_blue.mp4", "ipfs://QmYS9pmowSuf3GjSQ5vX3SBUfzmEiNT6k9BMnAFXoJUYpX/1", "Rare", "Rare", "OG", 0, 0, "None", "None", false);
                NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom3, ram3, 60);

                index := index + 1;
//                _speckyGhostId := _speckyGhostId + 1;
            }
        }
    }

    public setBlootWhitelist(ethAddress: string, claimable: number) {
        // check witness
        Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        _blootWhitelist.set(ethAddress, claimable);
    }

    public mintBlootCrate(owner:address, ethAddress: string) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(owner), "invalid witness");

        // check if all bloot crates are sold out
        Runtime.expect(_blootBoxCurrentID <= _blootBoxMaxSupply, "The bloot crate is all sold out");

        local claimable: number := _blootWhitelist.get(ethAddress);
        // check if this user is able to claim
        Runtime.expect(claimable > 0, "You already claimed your Bloot Crates");
        // 4 bloot crates per zen elf
        claimable := claimable * 4;

        local index: number := 1;
        while (index <= claimable) {
            // mint bloot box
            local rom1:box_rom := Struct.box_rom(_royalty);
            local ram1:box_ram := Struct.box_ram("Bloot Crate", "Bloot Crate", "ipfs://QmW2jJSmeADosXLd6QHeVrXCP5qUtF7cwkaJFVmMm4YsgE/Crate_4.mp4", "ipfs://QmVcJ86C1etNEqhyPwSQRwd93Rsp4o7keTGPKGv4FD9VTf/" + _blootBoxCurrentID);

            local boxTokenID: number := NFT.mint(_addressOwner, owner, $THIS_SYMBOL, rom1, ram1, 4);
            _blootBoxIdToTokenID.set(boxTokenID, _blootBoxCurrentID);
            _blootBoxCurrentID := _blootBoxCurrentID + 1;

            index := index + 1;
        }

        _blootWhitelist.set(ethAddress, 0);

    }

    public burnBlootCrateOnWebsite(from:address, symbol:string, tokenID:number) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");
        
        _burnMap.set(tokenID, true);
        NFT.burn(from, symbol, tokenID);

        local _blootBoxCurrentID: number := _blootBoxIdToTokenID.get(tokenID);

        _blootBoxIdToTokenID.remove(tokenID);

        if (_blootBoxCurrentID <= 0) {
            return;
        }

        if (symbol != $THIS_SYMBOL) {
            return;
        }

        local temp: number := 0;

        // mint hammer
        local rom2:hammer_rom := Struct.hammer_rom(_royalty);
        local ram2:hammer_ram := Struct.hammer_ram("Rare Bloot Hammer", "Rare Bloot Hammer", "ipfs://QmW2jJSmeADosXLd6QHeVrXCP5qUtF7cwkaJFVmMm4YsgE/hammer_bloot_1.mp4", "ipfs://QmcSqHDDPY1HCTAosRxygZHd8dt9hNXmsvauvMezLCju5g/" + _blootBoxCurrentID, "Rare", "Regular", "OG", 0, 0, "None", "None");
        NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom2, ram2, 41);

        // mint ghost
        local rom3: ghost_rom := Struct.ghost_rom(_royalty);
        local ram3: ghost_ram := Struct.ghost_ram("Rare Bloot Ghost", "Rare Bloot Ghost", "ipfs://QmW2jJSmeADosXLd6QHeVrXCP5qUtF7cwkaJFVmMm4YsgE/Ghost_Bloot_1.mp4", "ipfs://QmNZoGVigjBf1rv4Y9gbpj6BW6em71PCTtidkdQLtfeAyA/" + _blootBoxCurrentID, "Rare", "Regular", "OG", 0, 0, "None", "None", false);
        NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom3, ram3, 59);
    }

    public fuseHammer(from:address, tokenID1:number, tokenID2:number, tcktBurn:number, name:string, description:string, imageURL:string, infoURL:string, rarity:string, model:string, hammerType:string, level:number, power:number, infusedType1:string, infusedType2:string) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");

        local tcktBalance:number := Token.getBalance(from, _tcktSymbol);
        // Make sure the TCKT balance is greater than the amount to be burned
        Runtime.expect(tcktBalance >= tcktBurn, "Insufficient TCKT balance");

        // burn x % of TCKT and second NFT
        Token.burn(from, _tcktSymbol, tcktBurn);
        _burnMap.set(tokenID2, true);
        NFT.burn(from, $THIS_SYMBOL, tokenID2);

        // fuse NFT
        local ram:hammer_ram := Struct.hammer_ram(name, description, imageURL, infoURL, rarity, model, hammerType, level, power, infusedType1, infusedType2);
        NFT.write(from, $THIS_SYMBOL, tokenID1, ram);
    }

    public upgradeHammer(from:address, tokenID:number, tcktBurn:number, name:string, description:string, imageURL:string, infoURL:string, rarity:string, model:string, hammerType:string, level:number, power:number, infusedType1:string, infusedType2:string) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");

        local tcktBalance:number := Token.getBalance(from, _tcktSymbol);
        // Make sure the TCKT balance is greater than the amount to be burned
        Runtime.expect(tcktBalance >= tcktBurn, "Insufficient TCKT balance");

        // burn x % of TCKT
        Token.burn(from, _tcktSymbol, tcktBurn);

        // upgrade NFT
        local ram:hammer_ram := Struct.hammer_ram(name, description, imageURL, infoURL, rarity, model, hammerType, level, power, infusedType1, infusedType2);
        NFT.write(from, $THIS_SYMBOL, tokenID, ram);
    }

    public fuseGhost(from:address, tokenID1:number, tokenID2:number, tcktBurn:number, name:string, description:string, imageURL:string, infoURL:string, rarity:string, model:string, ghostType:string, level:number, health:number, infusedType1:string, infusedType2:string, unboxed:bool) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");

        local tcktBalance:number := Token.getBalance(from, _tcktSymbol);
        // Make sure the TCKT balance is greater than the amount to be burned
        Runtime.expect(tcktBalance >= tcktBurn, "Insufficient TCKT balance");

        // burn x % of TCKT and second NFT
        Token.burn(from, _tcktSymbol, tcktBurn);
        _burnMap.set(tokenID2, true);
        NFT.burn(from, $THIS_SYMBOL, tokenID2);

        // fuse NFT
        local ram:ghost_ram := Struct.ghost_ram(name, description, imageURL, infoURL, rarity, model, ghostType, level, health, infusedType1, infusedType2, unboxed);
        NFT.write(from, $THIS_SYMBOL, tokenID1, ram);
    }

    public upgradeGhost(from:address, tokenID:number, tcktBurn:number, name:string, description:string, imageURL:string, infoURL:string, rarity:string, model:string, ghostType:string, level:number, health:number, infusedType1:string, infusedType2:string, unboxed:bool) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");

        local tcktBalance:number := Token.getBalance(from, _tcktSymbol);
        // Make sure the TCKT balance is greater than the amount to be burned
        Runtime.expect(tcktBalance >= tcktBurn, "Insufficient TCKT balance");

        // burn x % of TCKT
        Token.burn(from, _tcktSymbol, tcktBurn);

        // upgrade NFT
        local ram:ghost_ram := Struct.ghost_ram(name, description, imageURL, infoURL, rarity, model, ghostType, level, health, infusedType1, infusedType2, unboxed);
        NFT.write(from, $THIS_SYMBOL, tokenID, ram);
    }

    public fuseHammerTest(from:address, name:string, description:string, imageURL:string, infoURL:string, rarity:string, model:string, hammerType:string, level:number, power:number, infusedType1:string, infusedType2:string) {
        // check is witness and is current owner
        Runtime.expect(Runtime.isWitness(from), "invalid witness");

        NFT.createSeries(_addressOwner, $THIS_SYMBOL, 41, 100, TokenSeries.Duplicated, hammerNft);
        local rom:hammer_rom := Struct.hammer_rom(_royalty);
        local ram:hammer_ram := Struct.hammer_ram("Rare Bloot Hammer", "Rare Bloot Hammer", "ipfs://QmW2jJSmeADosXLd6QHeVrXCP5qUtF7cwkaJFVmMm4YsgE/hammer_bloot_1.mp4", "ipfs://QmcSqHDDPY1HCTAosRxygZHd8dt9hNXmsvauvMezLCju5g/" + _blootBoxCurrentID, "Rare", "Regular", "OG", 0, 0, "None", "None");
        local tokenID:number := NFT.mint(_addressOwner, from, $THIS_SYMBOL, rom, ram, 41);

        // fuse NFT
        local ram2:hammer_ram := Struct.hammer_ram(name, description, imageURL, infoURL, rarity, model, hammerType, level, power, infusedType1, infusedType2);
        NFT.write(from, $THIS_SYMBOL, tokenID, ram2);
    }

    trigger onBurn(from:address, to:address, symbol:string, tokenID:number) {
        local isValidBurn: bool := _burnMap.get(tokenID);
        Runtime.expect(isValidBurn == true, "Please try to burn on the Ghost Festival website");
    }

	/// @dev onUpgrade trigger.
    /// @param from - Address from - address
	trigger onUpgrade(from:address)
    {
        // check is witness and is current owner
		Runtime.expect(Runtime.isWitness(_addressOwner), "invalid witness");

        _tcktSymbol := "TCKT";
    }
}